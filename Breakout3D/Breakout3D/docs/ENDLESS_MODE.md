# Endless Mode (Technical Documentation)

This document describes **exactly** how Endless Mode works in Breakout3D: gameplay rules, spawning logic, difficulty ramp, scoring, persistence, UI warnings, and power-ups. It is written to match the current implementation in the codebase.

---

## Overview

Endless Mode is an infinite survival variant:

- There is **no WIN state**. The session ends only when a brick reaches the paddle’s “death line”.
- New bricks are continuously introduced via **two spawn systems**:
  - **Brick-destroy-based spawns** (progress pressure, tied to how many bricks you clear).
  - **Time-based spawns** (survival pressure, spawns even if you play perfectly).
- Scoring is designed around a **streak bank**:
  - Brick points accumulate into a “bank”.
  - If you stop scoring for a short time, the bank is committed into the real score.
- A persistent best score is stored on disk across runs.

Key source files:

- `include/game/GameState.hpp` (Endless state variables)
- `src/game/Game.cpp` (timers, streak banking, time-based spawns, danger/lose condition, UI)
- `src/game/systems/CollisionSystem.cpp` (brick destruction scoring, brick-destroy-based spawn trigger)
- `src/game/systems/InitSystem.cpp` (initialization, initial brick generation, best score load)
- `src/game/systems/PowerUpSystem.cpp` (power-up drop weights and effects)

---

## GameState fields (Endless-relevant)

All Endless state is stored in `game::GameState` (`include/game/GameState.hpp`).

### Core Endless progression/spawning

- **`int wave`**
  - Intended as an Endless “wave” counter.
  - **Current behavior**: in the shipped code, `wave` is set when switching into Endless, but is **not incremented over time**. It is still used in some calculations (e.g., scoring bonus), which currently results in a constant wave bonus.

- **`int bricksDestroyedThisWave`**
  - Counter of how many bricks have been destroyed since the last spawn “threshold” was met.
  - Used by the brick-destroy-based row spawn system.

- **`int pendingSpawnBricks`**
  - Queue of bricks to spawn later.
  - This exists to avoid mutating brick lists while iterating collisions.
  - When `pendingSpawnBricks > 0`, `Game::update()` performs the actual spawn and then resets this value to 0.

- **`int endlessRowsSpawned`**
  - Tracks total rows spawned so far in Endless.
  - Used for HP scaling of newly spawned bricks (see “HP scaling”).

### Time pressure

- **`float endlessSpawnCooldown`**
  - Small “cooldown gate” to prevent rapid back-to-back spawns.

- **`float endlessAutoTimer`**
  - Accumulates time for the time-based spawn system.

- **`float endlessElapsedTime`**
  - Total time spent in Endless **while in PLAYING**.
  - This is the basis for difficulty ramps (time-based spawn intervals and brick-destroy threshold).

### Streak banking score system

- **`int endlessStreakPoints`**
  - Points accumulated but not yet committed to the real score.

- **`float endlessStreakIdleTimer`**
  - Time since last streak point was gained.

- **`bool endlessStreakBanking`** / **`float endlessStreakBankTimer`**
  - Animation/timing state for the “banking” commit.

### Danger warning (UI/telemetry)

- **`bool endlessDangerActive`**
- **`float endlessDangerTimer`**
- **`float endlessDangerMaxZ`**

These control the red danger band + “DANGER!” overlay.

---

## Initialization & entering Endless

### Starting Endless

The menu sets the game type and starts the game. Endless Mode uses the same core game loop; only the *rules* and *spawn logic* differ.

### `InitSystem::initGame()`

In `src/game/systems/InitSystem.cpp`:

- Resets standard gameplay state (lives, score, ball/paddle, powerups, cooldowns).
- Resets Endless-specific counters:
  - `bricksDestroyedThisWave = 0`
  - `endlessRowsSpawned = 0`
  - streak-bank fields reset (`endlessStreakPoints`, timers, etc.)
  - danger fields reset (`endlessDangerActive`, timers)
  - `endlessElapsedTime = 0`
- Loads the persistent best score into:
  - `endlessBestScore = loadEndlessBestScore()`

### Initial brick field

The initial brick field for Endless is generated by `InitSystem::generateBricks(state, cfg, waveToGenerate)`:

- Endless uses `waveToGenerate = state.wave`.
- Row count increases with wave:
  - `rows = 9 + (waveNumber / 2)`
- **Important**: because `wave` is not incremented in current code, the initial rows remain tied to whatever `wave` was set to at start (often 1).

---

## Continuous brick spawning (Endless difficulty)

Endless uses **two** concurrent mechanisms that both end up increasing `pendingSpawnBricks` by 12 (one full row, given 12 columns).

### 1) Brick-destroy-based spawn (progress pressure)

Implementation: `src/game/systems/CollisionSystem.cpp`

When a brick’s HP reaches 0 (i.e. it is destroyed), Endless increments:

- `state.bricksDestroyedThisWave++`

Then it checks a **dynamic threshold** `required` (how many destroyed bricks are needed before spawning a new row):

- For the first 2 minutes: `required = 22`
- From 2 minutes to 10 minutes: `required` interpolates down to 15:
  - Let \(t\) = `endlessElapsedTime` (seconds)
  - \(u = \text{clamp01}((t - 120) / 480)\)
  - `required = round(22 - 7*u)` (22 → 15)
  - Clamped to `[15, 22]`

When the threshold is met:

- `pendingSpawnBricks += 12`
- `bricksDestroyedThisWave -= required`

This makes the early game easier (you need to clear more bricks before the next row), then gradually returns to the classic pace (15) later.

### 2) Time-based spawn (survival pressure)

Implementation: `src/game/Game.cpp`

In `Game::update()`:

- `endlessAutoTimer` always accumulates while in Endless (independent of pause vs play).
- `endlessElapsedTime` accumulates **only** while in `PLAYING`.

Time-based row spawn rules:

- Grace period: first **60 seconds**
  - No time-based spawns occur, and `endlessAutoTimer` is reset to 0 during grace.
- After grace:
  - A spawn interval is computed:
    - \(t = \text{endlessElapsedTime}\)
    - \(u = \text{clamp01}((t - 60) / 540)\) (0..1 over 9 minutes after grace)
    - `interval = 26 - 14*u` seconds → 26 down to 12
    - Clamped: minimum interval is **12 seconds**

Trigger:

- If `endlessAutoTimer >= interval` **and** `pendingSpawnBricks < 12`:
  - `pendingSpawnBricks += 12`
  - `endlessSpawnCooldown = 0.50f`
  - `endlessAutoTimer = 0.0f`

Notes:

- The `pendingSpawnBricks < 12` check prevents “stacking” multiple timed rows at once.
- `endlessSpawnCooldown` is a small gate used by other spawn paths as well.

---

## How rows are inserted into the world

Implementation: `InitSystem::spawnIncrementalBricks(state, cfg, count, waveNumber)` in `src/game/systems/InitSystem.cpp`.

When `pendingSpawnBricks` is non-zero, `Game::update()` calls `spawnIncrementalBricks(...)` and then clears `pendingSpawnBricks` back to 0.

### Row insertion behavior

Given `count` bricks:

- The system computes:
  - `cols = 12`
  - `rowsToInsert = ceil(count / cols)`
  - `push = rowsToInsert * stepZ`

Then:

- Every existing alive brick is pushed forward (towards the paddle) by `push` in Z.
- New bricks are spawned at the back (near `arenaMinZ`).

This means adding a row not only inserts bricks, but also advances the entire wall, increasing danger over time.

### HP scaling of spawned bricks

Newly spawned bricks get HP based on their global row index:

- `rowGlobal = totalRowsBefore + rowLocal`
  - `totalRowsBefore` is `endlessRowsSpawned` before insertion.
- `difficultyBonus = rowGlobal / 20`
- `hp = min(6, baseHp + difficultyBonus)`

---

## Lose condition (Endless only)

Implementation: `src/game/Game.cpp`

Endless checks for defeat by comparing the front-most alive brick against a limit near the paddle:

- `limitZ = paddlePos.z - 0.5f`
- For each alive brick, compute its front edge:
  - `brMaxZ = br.pos.z + br.size.z * 0.5f`
- If any `brMaxZ >= limitZ`, the game ends immediately:
  - Any pending streak bank is committed (so it counts).
  - Best score is updated and persisted (if applicable).
  - Mode becomes `GAME_OVER` and balls are cleared.

---

## Danger warning (UI + telemetry)

Implementation: `src/game/Game.cpp` (logic) and UI rendering inside the UI pass.

The warning activates before you actually lose. It’s based on the maximum alive brick Z:

- `warningThresholdZ = limitZ - (1.33f * 3.0f)` (about “3 rows away”)
- `endlessDangerActive = anyAlive && (maxZFound >= warningThresholdZ)`

When active:

- `endlessDangerTimer` increments (used as the phase for the flashing).
- `endlessDangerMaxZ` stores the current maximum Z for consistent positioning.

### Visual output

- A red translucent band is drawn below a computed “danger line” in screen space.
- A pulsing “DANGER!” label appears inside that band.
- “DANGER!” is rendered with a subtle thickness pass + main pass to read bold.

---

## Scoring (Endless)

Endless scoring is built around a **streak bank** so you get satisfying “chains” of points.

### Brick points

Implementation: `src/game/systems/CollisionSystem.cpp`

When a brick is destroyed, points are computed from its max HP:

- hp=1 → 50
- hp=2 → 120
- hp=3 → 220
- hp=4 → 350
- hp=5 → 500
- hp>=6 → 700

Then an Endless wave bonus is added:

- `waveBonus = wave * 25`

**Current note**: since `wave` is not incremented, the wave bonus is currently constant during a run.

### Streak bank vs real score

Implementation: `src/game/Game.cpp`, `src/game/systems/CollisionSystem.cpp`

In Endless:

- Brick destruction points do **not** immediately modify `state.score`.
- Instead, they are added to `state.endlessStreakPoints`.

Banking/commit behavior (in `Game::update()`):

- If no new points arrive for `idleToBank = 2.5f` seconds:
  - `endlessStreakBanking` becomes true and a short animation timer starts.
- After `bankAnim = 0.55f` seconds:
  - `commitEndlessStreak(state)` is called:
    - `score += endlessStreakPoints`
    - `endlessStreakPoints = 0`
    - streak timers reset
  - Best score may be updated (see persistence).

Commit on death:

- When you lose (brick crosses the death line), the streak is also committed immediately so those points count.

### Powerup pickup scoring (Endless only)

Implementation: `src/game/systems/PowerUpSystem.cpp`

On pickup, Endless adjusts the streak/score:

- `SLOW`: penalty of 300 (removes from streak first; remainder subtracts from score, clamped to >=0)
- `EXPAND`: +250 into streak
- `EXTRA_BALL`: +350 into streak
- `EXTRA_LIFE`: +500 into streak

---

## Best score / High score persistence

Endless persists a best score across runs.

### File path

Two implementations exist (same path) in:

- `src/game/Game.cpp`
- `src/game/systems/InitSystem.cpp`

Path logic:

- If `HOME` env var exists:
  - `${HOME}/.breakout3d_endless_best.txt`
- Otherwise:
  - `breakout3d_endless_best.txt` in the current working directory.

### Read/Write behavior

- Read happens during initialization (`InitSystem::initGame()` calls `loadEndlessBestScore()`).
- Write happens when the best score is beaten:
  - `saveEndlessBestScore(best)` writes the integer to the file (truncate/overwrite).

Best score updates are triggered when:

- A streak is committed (banked) and/or at game over.

---

## Power-ups (drop rates + effects)

Implementation: `src/game/systems/PowerUpSystem.cpp`

### Drop chance

Every brick destruction calls:

- `PowerUpSystem::spawnPowerUp(state, br.pos, cfg.powerUpChance)`

The drop is attempted with:

- `r = rand()/RAND_MAX`
- If `r > chance`, nothing spawns.

So `cfg.powerUpChance` controls the overall frequency.

### Type distribution (current)

If a drop occurs, type is chosen by `r2 = rand() % 100`:

- `EXTRA_BALL`: 45%
- `EXPAND`: 20%
- `SLOW`: 17%
- `EXTRA_LIFE`: 18%

### EXTRA_BALL behavior

On `EXTRA_BALL`, three new balls are spawned:

- Spawn origin: first active ball position, otherwise just in front of the paddle.
- 3 angles: -30°, 0°, +30° (in XZ plane)
- Speed: `cfg.ballSpeed`

---

## Debug / developer hooks

Implementation: `src/game/Game.cpp`

- Pressing `K3` in Endless triggers a manual row spawn via `spawnIncrementalBricks(...)` and resets relevant timers.

---

## Tuning guide (where to change difficulty)

### Time-based pressure

Edit in `src/game/Game.cpp` (time-based pressure block):

- Grace period: `grace = 60.0f`
- Interval range: `26.0f` down to `12.0f`
- Ramp duration: `(t - grace) / 540.0f` (9 minutes)

### Brick-destroy pressure

Edit in `src/game/systems/CollisionSystem.cpp`:

- Early requirement: 22
- Late requirement: 15
- Ramp window: 2min → 10min (`(t - 120) / 480`)

### Brick HP scaling

Edit in `src/game/systems/InitSystem.cpp`:

- `difficultyBonus = rowGlobal / 20`
- `hp = min(6, baseHp + difficultyBonus)`


